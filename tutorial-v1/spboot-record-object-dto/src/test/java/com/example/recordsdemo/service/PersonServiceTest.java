package com.example.recordsdemo.service;

import com.example.recordsdemo.model.Person;
import com.example.recordsdemo.model.Address;
import com.example.recordsdemo.model.Contact;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

class PersonServiceTest {

    private PersonService personService;
    private Address testAddress;
    private List<Contact> testContacts;
    private List<String> testHobbies;

    @BeforeEach
    void setUp() {
        personService = new PersonService();

        testAddress = Address.builder()
                .street("123 Main St")
                .city("Houston")
                .state("TX")
                .zipCode("77001")
                .country("USA")
                .build();

        testContacts = List.of(
                new Contact("EMAIL", "john.doe@example.com"),
                new Contact("PHONE", "+1-555-123-4567")
        );

        testHobbies = List.of("Reading", "Swimming", "Coding");
    }

    @Test
    @DisplayName("Should create person with auto-generated ID")
    void shouldCreatePersonWithAutoGeneratedId() {
        // Given
        Person personToCreate = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        // When
        Person createdPerson = personService.createPerson(personToCreate);

        // Then
        assertAll(
                () -> assertNotNull(createdPerson.id()),
                () -> assertEquals("John", createdPerson.firstName()),
                () -> assertEquals("Doe", createdPerson.lastName()),
                () -> assertEquals(LocalDate.of(1990, 5, 15), createdPerson.birthDate()),
                () -> assertEquals(testAddress, createdPerson.address()),
                () -> assertEquals(testContacts, createdPerson.contacts()),
                () -> assertEquals(testHobbies, createdPerson.hobbies())
        );
    }

    @Test
    @DisplayName("Should find person by ID")
    void shouldFindPersonById() {
        // Given
        Person personToCreate = Person.builder()
                .firstName("Jane")
                .lastName("Smith")
                .birthDate(LocalDate.of(1985, 8, 20))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person createdPerson = personService.createPerson(personToCreate);

        // When
        Optional<Person> foundPerson = personService.findById(createdPerson.id());

        // Then
        assertAll(
                () -> assertTrue(foundPerson.isPresent()),
                () -> assertEquals(createdPerson, foundPerson.get())
        );
    }

    @Test
    @DisplayName("Should return empty when person not found")
    void shouldReturnEmptyWhenPersonNotFound() {
        // When
        Optional<Person> foundPerson = personService.findById(999L);

        // Then
        assertTrue(foundPerson.isEmpty());
    }

    @Test
    @DisplayName("Should update existing person")
    void shouldUpdateExistingPerson() {
        // Given
        Person originalPerson = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person createdPerson = personService.createPerson(originalPerson);

        Person updatedPersonData = Person.builder()
                .firstName("Jonathan")
                .lastName("Smith")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(List.of("Reading", "Gaming"))
                .build();

        // When
        Optional<Person> updatedPerson = personService.updatePerson(createdPerson.id(), updatedPersonData);

        // Then
        assertAll(
                () -> assertTrue(updatedPerson.isPresent()),
                () -> assertEquals(createdPerson.id(), updatedPerson.get().id()), // ID preserved
                () -> assertEquals("Jonathan", updatedPerson.get().firstName()),
                () -> assertEquals("Smith", updatedPerson.get().lastName()),
                () -> assertEquals(List.of("Reading", "Gaming"), updatedPerson.get().hobbies())
        );
    }

    @Test
    @DisplayName("Should return empty when updating non-existent person")
    void shouldReturnEmptyWhenUpdatingNonExistentPerson() {
        // Given
        Person updatedPersonData = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        // When
        Optional<Person> updatedPerson = personService.updatePerson(999L, updatedPersonData);

        // Then
        assertTrue(updatedPerson.isEmpty());
    }

    @Test
    @DisplayName("Should update person's address")
    void shouldUpdatePersonAddress() {
        // Given
        Person originalPerson = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person createdPerson = personService.createPerson(originalPerson);

        Address newAddress = Address.builder()
                .street("456 Oak Ave")
                .city("Dallas")
                .state("TX")
                .zipCode("75201")
                .country("USA")
                .build();

        // When
        Optional<Person> updatedPerson = personService.updateAddress(createdPerson.id(), newAddress);

        // Then
        assertAll(
                () -> assertTrue(updatedPerson.isPresent()),
                () -> assertEquals(newAddress, updatedPerson.get().address()),
                () -> assertEquals("John", updatedPerson.get().firstName()), // Other fields unchanged
                () -> assertEquals("Doe", updatedPerson.get().lastName())
        );
    }

    @Test
    @DisplayName("Should add contact to person")
    void shouldAddContactToPerson() {
        // Given
        Person originalPerson = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(List.of(new Contact("EMAIL", "john@example.com")))
                .hobbies(testHobbies)
                .build();

        Person createdPerson = personService.createPerson(originalPerson);
        Contact newContact = new Contact("LINKEDIN", "https://linkedin.com/in/johndoe");

        // When
        Optional<Person> updatedPerson = personService.addContact(createdPerson.id(), newContact);

        // Then
        assertAll(
                () -> assertTrue(updatedPerson.isPresent()),
                () -> assertEquals(2, updatedPerson.get().contacts().size()),
                () -> assertTrue(updatedPerson.get().contacts().contains(newContact)),
                () -> assertTrue(updatedPerson.get().hasContactType("LINKEDIN"))
        );
    }

    @Test
    @DisplayName("Should add hobby to person")
    void shouldAddHobbyToPerson() {
        // Given
        Person originalPerson = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(List.of("Reading"))
                .build();

        Person createdPerson = personService.createPerson(originalPerson);
        String newHobby = "Photography";

        // When
        Optional<Person> updatedPerson = personService.addHobby(createdPerson.id(), newHobby);

        // Then
        assertAll(
                () -> assertTrue(updatedPerson.isPresent()),
                () -> assertEquals(2, updatedPerson.get().hobbies().size()),
                () -> assertTrue(updatedPerson.get().hobbies().contains(newHobby)),
                () -> assertTrue(updatedPerson.get().hobbies().contains("Reading")) // Original hobby preserved
        );
    }

    @Test
    @DisplayName("Should get all persons")
    void shouldGetAllPersons() {
        // Given
        Person person1 = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person person2 = Person.builder()
                .firstName("Jane")
                .lastName("Smith")
                .birthDate(LocalDate.of(1985, 8, 20))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        personService.createPerson(person1);
        personService.createPerson(person2);

        // When
        List<Person> allPersons = personService.getAllPersons();

        // Then
        assertAll(
                () -> assertEquals(2, allPersons.size()),
                () -> assertTrue(allPersons.stream().anyMatch(p -> p.firstName().equals("John"))),
                () -> assertTrue(allPersons.stream().anyMatch(p -> p.firstName().equals("Jane")))
        );
    }

    @Test
    @DisplayName("Should delete person")
    void shouldDeletePerson() {
        // Given
        Person personToCreate = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person createdPerson = personService.createPerson(personToCreate);

        // When
        boolean deleted = personService.deletePerson(createdPerson.id());
        Optional<Person> foundPerson = personService.findById(createdPerson.id());

        // Then
        assertAll(
                () -> assertTrue(deleted),
                () -> assertTrue(foundPerson.isEmpty())
        );
    }

    @Test
    @DisplayName("Should return false when deleting non-existent person")
    void shouldReturnFalseWhenDeletingNonExistentPerson() {
        // When
        boolean deleted = personService.deletePerson(999L);

        // Then
        assertFalse(deleted);
    }

    @Test
    @DisplayName("Should find persons by hobby")
    void shouldFindPersonsByHobby() {
        // Given
        Person person1 = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(List.of("Reading", "Swimming"))
                .build();

        Person person2 = Person.builder()
                .firstName("Jane")
                .lastName("Smith")
                .birthDate(LocalDate.of(1985, 8, 20))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(List.of("Reading", "Cooking"))
                .build();

        Person person3 = Person.builder()
                .firstName("Bob")
                .lastName("Johnson")
                .birthDate(LocalDate.of(1992, 12, 10))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(List.of("Gaming", "Coding"))
                .build();

        personService.createPerson(person1);
        personService.createPerson(person2);
        personService.createPerson(person3);

        // When
        List<Person> readingLovers = personService.findByHobby("Reading");
        List<Person> gamers = personService.findByHobby("Gaming");

        // Then
        assertAll(
                () -> assertEquals(2, readingLovers.size()),
                () -> assertTrue(readingLovers.stream().anyMatch(p -> p.firstName().equals("John"))),
                () -> assertTrue(readingLovers.stream().anyMatch(p -> p.firstName().equals("Jane"))),

                () -> assertEquals(1, gamers.size()),
                () -> assertEquals("Bob", gamers.get(0).firstName())
        );
    }

    @Test
    @DisplayName("Should find persons by contact type")
    void shouldFindPersonsByContactType() {
        // Given
        Person person1 = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(List.of(
                        new Contact("EMAIL", "john@example.com"),
                        new Contact("PHONE", "+1-555-123-4567")
                ))
                .hobbies(testHobbies)
                .build();

        Person person2 = Person.builder()
                .firstName("Jane")
                .lastName("Smith")
                .birthDate(LocalDate.of(1985, 8, 20))
                .address(testAddress)
                .contacts(List.of(
                        new Contact("EMAIL", "jane@example.com"),
                        new Contact("LINKEDIN", "https://linkedin.com/in/janesmith")
                ))
                .hobbies(testHobbies)
                .build();

        Person person3 = Person.builder()
                .firstName("Bob")
                .lastName("Johnson")
                .birthDate(LocalDate.of(1992, 12, 10))
                .address(testAddress)
                .contacts(List.of(
                        new Contact("PHONE", "+1-555-987-6543")
                ))
                .hobbies(testHobbies)
                .build();

        personService.createPerson(person1);
        personService.createPerson(person2);
        personService.createPerson(person3);

        // When
        List<Person> emailUsers = personService.findByContactType("EMAIL");
        List<Person> phoneUsers = personService.findByContactType("PHONE");
        List<Person> linkedinUsers = personService.findByContactType("LINKEDIN");

        // Then
        assertAll(
                () -> assertEquals(2, emailUsers.size()),
                () -> assertTrue(emailUsers.stream().anyMatch(p -> p.firstName().equals("John"))),
                () -> assertTrue(emailUsers.stream().anyMatch(p -> p.firstName().equals("Jane"))),

                () -> assertEquals(2, phoneUsers.size()),
                () -> assertTrue(phoneUsers.stream().anyMatch(p -> p.firstName().equals("John"))),
                () -> assertTrue(phoneUsers.stream().anyMatch(p -> p.firstName().equals("Bob"))),

                () -> assertEquals(1, linkedinUsers.size()),
                () -> assertEquals("Jane", linkedinUsers.get(0).firstName())
        );
    }

    @Test
    @DisplayName("Should demonstrate complete workflow with Builder pattern")
    void shouldDemonstrateCompleteWorkflowWithBuilderPattern() {
        // Given - Create person using Builder pattern
        Person originalPerson = Person.builder()
                .firstName("Alice")
                .lastName("Cooper")
                .birthDate(LocalDate.of(1988, 3, 22))
                .address(Address.builder()
                        .street("789 Rock Ave")
                        .city("Detroit")
                        .state("MI")
                        .zipCode("48201")
                        .build())
                .addContact(Contact.builder()
                        .type("EMAIL")
                        .value("alice@rockstar.com")
                        .build())
                .addContact(Contact.builder()
                        .type("PHONE")
                        .value("+1-555-ROCK-123")
                        .build())
                .addHobby("Music")
                .addHobby("Performing")
                .build();

        // When - Create and update person through service
        Person createdPerson = personService.createPerson(originalPerson);

        // Add more contacts and hobbies
        Person updatedPerson1 = personService.addContact(createdPerson.id(),
                new Contact("TWITTER", "@alicecooper")).orElseThrow();

        Person updatedPerson2 = personService.addHobby(updatedPerson1.id(),
                "Songwriting").orElseThrow();

        // Update address
        Address newAddress = Address.builder()
                .street("123 New Stage St")
                .city("Nashville")
                .state("TN")
                .zipCode("37201")
                .build();

        Person finalPerson = personService.updateAddress(updatedPerson2.id(), newAddress).orElseThrow();

        // Then - Verify all changes
        assertAll(
                () -> assertNotNull(finalPerson.id()),
                () -> assertEquals("Alice", finalPerson.firstName()),
                () -> assertEquals("Cooper", finalPerson.lastName()),
                () -> assertEquals(3, finalPerson.contacts().size()),
                () -> assertEquals(3, finalPerson.hobbies().size()),
                () -> assertTrue(finalPerson.hasContactType("TWITTER")),
                () -> assertTrue(finalPerson.hobbies().contains("Songwriting")),
                () -> assertEquals("Nashville", finalPerson.address().city()),
                () -> assertEquals("123 New Stage St", finalPerson.address().street())
        );

        // Verify original person in storage is updated
        Optional<Person> retrievedPerson = personService.findById(finalPerson.id());
        assertTrue(retrievedPerson.isPresent());
        assertEquals(finalPerson, retrievedPerson.get());
    }

    @Test
    @DisplayName("Should handle concurrent ID generation")
    void shouldHandleConcurrentIdGeneration() {
        // Given
        Person person1 = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        Person person2 = Person.builder()
                .firstName("Jane")
                .lastName("Smith")
                .birthDate(LocalDate.of(1985, 8, 20))
                .address(testAddress)
                .contacts(testContacts)
                .hobbies(testHobbies)
                .build();

        // When
        Person created1 = personService.createPerson(person1);
        Person created2 = personService.createPerson(person2);

        // Then
        assertAll(
                () -> assertNotNull(created1.id()),
                () -> assertNotNull(created2.id()),
                () -> assertNotEquals(created1.id(), created2.id()),
                () -> assertTrue(created2.id() > created1.id()) // Sequential ID generation
        );
    }

    @Test
    @DisplayName("Should demonstrate immutability through service operations")
    void shouldDemonstrateImmutabilityThroughServiceOperations() {
        // Given
        Person originalPerson = Person.builder()
                .firstName("John")
                .lastName("Doe")
                .birthDate(LocalDate.of(1990, 5, 15))
                .address(testAddress)
                .contacts(List.of(new Contact("EMAIL", "john@example.com")))
                .hobbies(List.of("Reading"))
                .build();

        Person createdPerson = personService.createPerson(originalPerson);

        // Store references to verify immutability
        List<Contact> originalContacts = createdPerson.contacts();
        List<String> originalHobbies = createdPerson.hobbies();
        Address originalAddress = createdPerson.address();

        // When - Perform various updates
        personService.addContact(createdPerson.id(), new Contact("PHONE", "123-456-7890"));
        personService.addHobby(createdPerson.id(), "Gaming");

        Address newAddress = Address.builder()
                .street("456 New St")
                .city("New City")
                .state("TX")
                .zipCode("12345")
                .build();
        personService.updateAddress(createdPerson.id(), newAddress);

        // Then - Verify original objects are unchanged
        assertAll(
                () -> assertEquals(1, originalContacts.size()),
                () -> assertEquals(1, originalHobbies.size()),
                () -> assertEquals("123 Main St", originalAddress.street()),
                () -> assertEquals("Houston", originalAddress.city())
        );

        // Verify service returns updated person
        Person updatedPerson = personService.findById(createdPerson.id()).orElseThrow();
        assertAll(
                () -> assertEquals(2, updatedPerson.contacts().size()),
                () -> assertEquals(2, updatedPerson.hobbies().size()),
                () -> assertEquals("456 New St", updatedPerson.address().street()),
                () -> assertEquals("New City", updatedPerson.address().city())
        );
    }
}